# -*- coding: utf-8 -*-
# @Time    : 2024/4/16 11:06
# @Author  : Dongliang

import os

import numpy as np
import scipy


def read_varlen(path, dimension, num_class):
    """
    Read variable-length trajectory datasets.

    :param path: The path and filename of the trajectory dataset.
    :param dimension: The dimension of the trajectory, e.g. 2-D or 3-D.
    :param num_class: Number of trajectory types in the dataset.
    :return: Trajectory data, length and label.
    """

    with open(path, "r") as f:
        data = f.read().strip('[]').split(',')

    num_traces = len(data)
    sim_data = []
    sim_len = np.zeros(num_traces, dtype='float32')
    for i, trace in enumerate(data):
        trace_data = [float(val) for val in trace.split() if val not in ['x:', 'y:', 'z:', '']]
        trace_len = len(trace_data) // dimension
        sim_len[i] = trace_len
        trace_arr = np.array(trace_data, dtype='float32').reshape(trace_len, dimension)
        sim_data.append(trace_arr)

    num_perclass = num_traces // num_class
    sim_label = np.repeat(np.arange(num_class), num_perclass)
    return sim_data, sim_len, sim_label


def read_java_txt(path, flag, trace_len, dimension, num_classes):
    """
    Reads a simulated trajectory dataset in .txt format generated by a Java program.

    :param path: The path and filename of the trajectory dataset.
    :param flag: The type of track, e.g. "Fixed length" or "Variable length".
    :param trace_len: The length of the trajectory.
    :param dimension: The dimension of the trajectory, e.g. 2-D or 3-D.
    :param num_classes: Number of trajectory types in the dataset.
    :return: Trajectory data, length and label.
    """

    with open(path, "r") as f:
        data = f.read().strip('[]').split(',')

    num_traces = len(data)

    if flag == "Variable length":
        sim_data = []
    else:
        sim_data = np.zeros((num_traces, trace_len, dimension), dtype='float32')

    sim_length = np.zeros(num_traces, dtype='int32')

    for i, trace in enumerate(data):
        trace_data = [float(val) for val in trace.split() if val not in ['x:', 'y:', 'z:', '']]
        trace_len = len(trace_data) // dimension
        sim_length[i] = trace_len
        trace_arr = np.array(trace_data, dtype='float32').reshape(trace_len, dimension)

        if flag == "Variable length":
            sim_data.append(trace_arr)
        else:
            sim_data[i, :trace_len] = trace_arr

    if flag == "Variable length":
        sim_data = np.concatenate(sim_data, axis=0)

    num_perclass = num_traces // num_classes
    sim_label = np.repeat(np.arange(num_classes), num_perclass)

    return sim_data, sim_length, sim_label


if __name__ == '__main__':
    print()
    path = r'D:\TrajSeg-Cls\TrajSEG-CLS_V3\SEG\Mixed-SNR'
    trace_len = 201
    dimension = 3
    num_classes = 5

    # flag = 'Variable length'
    flag = 'Fixed length'

    # Define file paths
    file_paths = {
        'train': os.path.join(path, 'training.txt'),
        'val': os.path.join(path, 'validation.txt'),
        'test': os.path.join(path, 'test.txt')
    }

    # Process and save datasets
    for key in file_paths.keys():
        data, length, label = read_java_txt(file_paths[key], flag, trace_len, dimension, num_classes)
        save_path = os.path.join(path, f'{key}set.mat')
        scipy.io.savemat(save_path, {f'{key}set': data, f'{key}label': label, 'length': length})
